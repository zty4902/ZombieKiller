using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

namespace GimmeDOTSGeometry
{


    public static class Voronoi2DJobs
    {

        //First attempt, where I tried to calculate Voronoi Diagrams directly -> bad idea
        //Intersecting parabolas and calculating circumcircles in
        //this way is incredibly unstable with floating point precision... to make it actually
        //work you'd need arbitrary-precision arithmetic.

        //In any case -> Now the voronoi diagrams are generated by calculating the dual of 
        //a delaunay triangulation.
        /*

        public enum EventType
        {
            SITE_EVENT = 0,
            CIRCLE_EVENT = 1,
        }

        public unsafe struct EventPoint
        {
            public float2 position;
            public float2 circlePosition;
            public int leafPtr;
            public int site;

            public EventType type;


            public override string ToString()
            {
                string format = "{0:0.00}";
                return $"{string.Format(format, this.position.x)}|{string.Format(format, this.position.y)}";
            }

        }

        public unsafe struct EventPointComparer : IComparer<EventPoint>
        {
            public float epsilon;


            public int Compare(EventPoint pointA, EventPoint pointB)
            {
                float2 diff = pointB.position - pointA.position;
                if (Hint.Likely(math.abs(diff.y) > this.epsilon))
                {
                    return (int)math.sign(diff.y);
                }
                else if (Hint.Likely(math.abs(diff.x) > this.epsilon))
                {
                    return (int)-math.sign(diff.x);
                }
                return 0;
            }
        }

        //In contrast to all suggestions of books and the internet, I will only
        //store the breakpoints. A site point is never stored directly or only once
        //Each breakpoint stores the circle event of the arc to its right (so it works
        //nicely together with the skip list)
        public unsafe struct StatusEntry
        {
            public int rightCircleEventPtr;
            public int halfEdgePtr;
            public int leftSiteIdx;
            public int rightSiteIdx;

            public float2 leftSite;
            public float2 rightSite;

            public override string ToString()
            {
                string format = "{0:0.0}";
                return $"x:{string.Format(format, this.leftSite.x)} y:{string.Format(format, this.leftSite.y)}||" +
                    $"x:{string.Format(format, this.rightSite.x)} y:{string.Format(format, this.rightSite.y)}";
            }

            public float2 Midpoint()
            {
                return (this.leftSite + this.rightSite) * 0.5f;
            }

            public float2 BisectorDirection()
            {
                return (this.leftSite - this.rightSite).Perpendicular();
            }

            public void Breakpoint(float sweepLine, out float2 i0, out float2 i1, float epsilon = 10e-5f)
            {
                if (this.rightSite.Equals(this.leftSite))
                {
                    i0 = this.rightSite;
                    i1 = this.leftSite;
                    return;
                }

                //TODO Find out correct ordering (either x0 or x1)

                //Essentially intersecting two parabolas (that change with the sweep line)

                //Always positive!
                float leftDiv = (this.leftSite.y - sweepLine);
                float rightDiv = (this.rightSite.y - sweepLine);
                float lsq = sweepLine * sweepLine;

                if (leftDiv > epsilon && rightDiv > epsilon)
                {
                    float denomLeft = 1.0f / (2.0f * leftDiv);
                    float denomRight = 1.0f / (2.0f * rightDiv);

                    float leftA = denomLeft;
                    float rightA = denomRight;

                    float leftB = -2.0f * this.leftSite.x * denomLeft;
                    float rightB = -2.0f * this.rightSite.x * denomRight;

                    float leftC = (math.dot(this.leftSite, this.leftSite) - lsq) * denomLeft;
                    float rightC = (math.dot(this.rightSite, this.rightSite) - lsq) * denomRight;

                    var parA = new Parabola(leftA, leftB, leftC);
                    var parB = new Parabola(rightA, rightB, rightC);

                    GraphFunctionIntersections.ParabolaIntersections(parA, parB, out i0, out i1);
                }
#if !GDG_UNSAFE_DEGENERACIES
                //Happens when two sites encountered in the diagram have the same Y-Coordinate
                else if(leftDiv < epsilon && rightDiv < epsilon)
                {
                    float2 center = (this.rightSite + this.leftSite) * 0.5f;
                    i0 = center;
                    i1 = center;
                }
#endif
                //New Site
                else if (leftDiv < epsilon)
                {
                    float denomRight = 1.0f / (2.0f * rightDiv);

                    float rightA = denomRight;
                    float rightB = -2.0f * this.rightSite.x * denomRight;
                    float rightC = (math.dot(this.rightSite, this.rightSite) - lsq) * denomRight;

                    var parB = new Parabola(rightA, rightB, rightC);

                    float eval = parB.Evaluate(this.leftSite.x);
                    i0 = new float2(this.leftSite.x, eval);
                    i1 = i0;
                }
                else
                {
                    float denomLeft = 1.0f / (2.0f * leftDiv);

                    float leftA = denomLeft;
                    float leftB = -2.0f * this.leftSite.x * denomLeft;
                    float leftC = (math.dot(this.leftSite, this.leftSite) - lsq) * denomLeft;

                    var parA = new Parabola(leftA, leftB, leftC);

                    float eval = parA.Evaluate(this.rightSite.x);
                    i0 = new float2(this.rightSite.x, eval);
                    i1 = i0;
                }

            }
        }


        public unsafe struct StatusEntryComparer : IComparer<StatusEntry>
        {
            public float epsilon;

            public float sweepLine;



            public int Compare(StatusEntry statusX, StatusEntry statusY)
            {

                statusX.Breakpoint(this.sweepLine, out float2 xi0, out float2 xi1, this.epsilon);
                statusY.Breakpoint(this.sweepLine, out float2 yi0, out float2 yi1, this.epsilon);

                float diff = xi1.x - yi1.x;
                if (math.abs(diff) < this.epsilon)
                {
                    //Special Case: Vertices
                    bool leftEqual = math.all(statusX.leftSite == statusY.leftSite);
                    bool rightEqual = math.all(statusX.rightSite == statusY.rightSite);
                    if (leftEqual && rightEqual) return 0;

                    //Sites
                    if (math.all(statusX.leftSite == statusY.rightSite)
                        && math.all(statusX.rightSite == statusY.leftSite)) {
                        return 0;
                    }
                    else
                    {
                        //Resolve circle ties

                        return 0;
                    }
                }
                return xi1.x.CompareTo(yi1.x);
            }
        }


        //Fortune's Algorithm - based on a description from the book Computational Geometry, Mark de Berg et al.
        [BurstCompile(FloatPrecision = FloatPrecision.High)]
        public unsafe struct Voronoi2DSweep : IJob
        {
            #region Public Fields

            public float epsilon;

            [ReadOnly, NoAlias]
            public NativeArray<float2> points;


            [NoAlias]
            public NativeList<float2> vertices;

            [NoAlias]
            public NativeList<HalfEdge> halfEdges;

            [NoAlias, WriteOnly]
            public NativeList<int> halfEdgeSites;

            [NoAlias, ReadOnly]
            public NativeReference<Rect> bounds;

            #endregion

            #region Private Fields

            private float sweepLine;
            private float sweepEnd;

            #endregion



            private int2 MakeBorderVertices(NativeList<float2> vertices, float2 breakPoint, float2 bisectorDir)
            {
                var line = new Line2D(breakPoint, bisectorDir);
                ShapeIntersection.LineRectangleIntersections(line, this.bounds.Value, out var i0, out var i1, this.epsilon);

                int2 indices = new int2();

                if (i0.y > i1.y)
                {
                    vertices.Add(i0);
                    vertices.Add(i1);
                } else
                {
                    vertices.Add(i1);
                    vertices.Add(i0);
                }

                indices.x = vertices.Length - 2;
                indices.y = vertices.Length - 1;

                return indices;
            }

            public void HandleSiteEvent(EventPoint eventPoint,
                ref NativeSortedList<EventPoint, EventPointComparer> eventQueue,
                ref NativeSortedList<StatusEntry, StatusEntryComparer> status)
            {
                if (status.IsEmpty())
                {
                    var arc = new StatusEntry()
                    {
                        rightCircleEventPtr = -1,
                        leftSite = eventPoint.position,
                        rightSite = eventPoint.position,
                        leftSiteIdx = eventPoint.site,
                        rightSiteIdx = eventPoint.site,
                        halfEdgePtr = -1,
                    };

                    status.Insert(arc);
                }
                else
                {

                    var searchStatus = new StatusEntry()
                    {
                        leftSite = eventPoint.position,
                        rightSite = eventPoint.position
                    };

                    StatusEntry arcElem = default;

                    var leftPointer = status.GetClosestPointer(searchStatus, out _);

                    var leftBreak = new StatusEntry()
                    {
                        rightSite = eventPoint.position,
                        leftSite = eventPoint.position,
                        rightSiteIdx = eventPoint.site,
                        leftSiteIdx = eventPoint.site,
                        rightCircleEventPtr = -1,
                    };

                    var rightBreak = new StatusEntry()
                    {
                        rightSite = eventPoint.position,
                        leftSite = eventPoint.position,
                        rightSiteIdx = eventPoint.site,
                        leftSiteIdx = eventPoint.site,
                        rightCircleEventPtr = -1,
                    };

                    float2 arcSite = float2.zero;
                    int arcSiteIdx;
                    if (leftPointer.node >= 0)
                    {
                        var leftNode = status.m_NodeBuffer[leftPointer.node];
                        arcElem = leftNode.element;

                        arcSite = arcElem.rightSite;
                        arcSiteIdx = arcElem.rightSiteIdx;
                    }
                    else
                    {
                        var rightPointer = status.m_PointerBuffer[leftPointer.forwards];
                        var rightNode = status.m_NodeBuffer[rightPointer.node];

                        arcElem = rightNode.element;

                        arcSite = arcElem.leftSite;
                        arcSiteIdx = arcElem.leftSiteIdx;
                    }

                    //Handle False Alarm
                    if (arcElem.rightCircleEventPtr >= 0)
                    {
                        var rightCircleEvent = eventQueue.m_NodeBuffer[arcElem.rightCircleEventPtr];
                        eventQueue.Remove(rightCircleEvent.element);
                    }

                    leftBreak.leftSite = arcSite;
                    leftBreak.leftSiteIdx = arcSiteIdx;
                    if (math.abs(eventPoint.position.y - arcElem.rightSite.y) > this.epsilon)
                    {
                        rightBreak.rightSite = arcSite;
                        rightBreak.rightSiteIdx = arcSiteIdx;
                    }

                    //Special case for vertices
                    if (math.all(arcElem.leftSite == arcElem.rightSite))
                    {
                        status.Remove(arcElem);
                    }

                    int currentEdgeCount = this.halfEdges.Length;

                    float2 breakpoint = leftBreak.Midpoint();
                    float2 bisectorDir = leftBreak.BisectorDirection();

                    var indices = this.MakeBorderVertices(this.vertices, breakpoint, bisectorDir);

                    var breakEdge0 = new HalfEdge(-1, -1, indices.y, indices.x, currentEdgeCount + 1);
                    var breakEdge1 = new HalfEdge(-1, -1, indices.x, indices.y, currentEdgeCount);

                    this.halfEdges.Add(breakEdge0);
                    this.halfEdges.Add(breakEdge1);

                    if (bisectorDir.y < 0.0f)
                    {
                        this.halfEdgeSites.Add(leftBreak.leftSiteIdx);
                        this.halfEdgeSites.Add(eventPoint.site);

                    }
                    else
                    {
                        this.halfEdgeSites.Add(eventPoint.site);
                        this.halfEdgeSites.Add(leftBreak.leftSiteIdx);
                    }

                    leftBreak.halfEdgePtr = currentEdgeCount;
                    rightBreak.halfEdgePtr = currentEdgeCount;

                    status.Insert(rightBreak, out int rightBreakNodeIdx);
                    status.Insert(leftBreak, out int leftBreakNodeIdx);

                    bool chooseLeft = true;
                    bool chooseRight = true;
                    
                    //It can happen that both triples on either side produce the same circle event with the
                    //same sites:
                    //
                    // \I     X  /
                    //0 \       /  4
                    //   -\___/-     <- Bad ascii of three parabolas on top of each other. Note that the triples <0, 1, 2> and <2, 3, 4> produce the same event
                    //  1 \_Y_/ 3       Of course, three vertically oriented points would never produce circle events, it is just to illustrate the point
                    //      |
                    //    2 Z
                    //We resolve this like so: If the intersection I is right of the site -> Choose right
                    //                         If the intersection I is left of the site -> Choose left
                    if(leftPointer.node >= 0 && leftPointer.forwards >= 0)
                    {
                        var rightPointer = status.m_PointerBuffer[leftPointer.forwards];

                        var rightRightNode = status.m_NodeBuffer[rightPointer.node];
                        var rightElem = rightRightNode.element;

                        if (math.all(rightElem.leftSite == arcElem.rightSite)
                            && math.all(rightElem.rightSite == arcElem.leftSite))
                        {

                            float2 leftLeftBreakpoint = arcElem.Midpoint();
                            float2 leftLeftBisectorDir = arcElem.BisectorDirection();

                            if (this.TestConvergence(leftLeftBreakpoint, leftLeftBisectorDir, breakpoint, bisectorDir, out var circlePoint))
                            {
                                if (circlePoint.x < eventPoint.position.x)
                                {
                                    chooseRight = false;
                                }
                                else if (circlePoint.x > eventPoint.position.y)
                                {
                                    chooseLeft = false;
                                }
                            }
                        }
                    }

                    if (chooseLeft && leftPointer.node >= 0)
                    {
                        float2 leftLeftBreakpoint = arcElem.Midpoint();
                        float2 leftLeftBisectorDir = arcElem.BisectorDirection();

                        if (this.TestConvergence(leftLeftBreakpoint, leftLeftBisectorDir, breakpoint, bisectorDir, out var circlePoint))
                        {
                            //This is allowed, because the intersection of two bisector lines is the circumcenter of a triangle
                            //(and analogously, the circumcenter of a tetrahedron is the intersection of three bisector planes etc.)
                            float circleRadius = math.length(arcElem.rightSite - circlePoint);
                            float2 circleEventPoint = circlePoint - new float2(0, 1) * circleRadius;
                            if (circleEventPoint.y <= this.sweepLine)
                            {

                                var circleEvent = new EventPoint()
                                {
                                    leafPtr = leftPointer.node,
                                    position = circleEventPoint,
                                    type = EventType.CIRCLE_EVENT,
                                    circlePosition = circlePoint,
                                    site = -1,
                                };
                                eventQueue.Insert(circleEvent, out int eventNodeIdx);

                                var leftNode = status.m_NodeBuffer[leftPointer.node];
                                arcElem.rightCircleEventPtr = eventNodeIdx;
                                leftNode.element = arcElem;
                                status.m_NodeBuffer[leftPointer.node] = leftNode;
                            }
                        }
                    }

                    if (chooseRight && leftPointer.forwards >= 0)
                    {
                        var rightPointer = status.m_PointerBuffer[leftPointer.forwards];

                        var rightRightNode = status.m_NodeBuffer[rightPointer.node];
                        var rightElem = rightRightNode.element;

                        float2 rightRightBreakpoint = rightElem.Midpoint();
                        float2 rightRightBisectorDir = rightElem.BisectorDirection();

                        if (this.TestConvergence(breakpoint, bisectorDir, rightRightBreakpoint, rightRightBisectorDir, out var circlePoint))
                        {
                            float circleRadius = math.length(rightBreak.rightSite - circlePoint);
                            float2 circleEventPoint = circlePoint - new float2(0, 1) * circleRadius;
                            if (circleEventPoint.y <= this.sweepLine)
                            {

                                var circleEvent = new EventPoint()
                                {
                                    leafPtr = rightBreakNodeIdx,
                                    position = circleEventPoint,
                                    type = EventType.CIRCLE_EVENT,
                                    circlePosition = circlePoint,
                                    site = -1,
                                };

                                eventQueue.Insert(circleEvent, out int eventNodeIdx);

                                var rightBreakNode = status.m_NodeBuffer[rightBreakNodeIdx];
                                rightBreak.rightCircleEventPtr = eventNodeIdx;
                                rightBreakNode.element = rightBreak;
                                status.m_NodeBuffer[rightBreakNodeIdx] = rightBreakNode;
                            }
                            
                        }

                    }


                }
            }

            private bool TestConvergence(float2 breakA, float2 bisectorDirA, float2 breakB, float2 bisectorDirB, out float2 circlePoint)
            {
                var line0 = new Line2D(breakA, bisectorDirA);
                var line1 = new Line2D(breakB, bisectorDirB);

                return ShapeIntersection.LineIntersection(line0, line1, out circlePoint);
            }

            public void HandleCircleEvent(EventPoint eventPoint,
                ref NativeSortedList<EventPoint, EventPointComparer> eventQueue,
                ref NativeSortedList<StatusEntry, StatusEntryComparer> status)
            {
                int leaf = eventPoint.leafPtr;

                var leafNode = status.m_NodeBuffer[leaf];

                status.Remove(leafNode.element);

                //Left Arc now points to arc right of the leaf
                var leftPointer = status.GetClosestPointer(leafNode.element, out _);
                var rightPointer = status.m_PointerBuffer[leftPointer.forwards];
                var rightNode = status.m_NodeBuffer[rightPointer.node];

                rightNode.element.leftSite = leafNode.element.leftSite;
                status.m_NodeBuffer[rightPointer.node] = rightNode;
                

                int leftEdgeIdx = leafNode.element.halfEdgePtr;
                int rightEdgeIdx = rightNode.element.halfEdgePtr;

                //Wiring up the circle edges
                var leftHalfEdge = this.halfEdges[leftEdgeIdx];
                var rightHalfEdge = this.halfEdges[rightEdgeIdx];

                var leftTwinEdge = this.halfEdges[leftHalfEdge.twin];
                var rightTwinEdge = this.halfEdges[rightHalfEdge.twin];

                float2 newBreakpoint = rightNode.element.Midpoint();
                float2 newBisectorDir = rightNode.element.BisectorDirection();

                var line = new Line2D(newBreakpoint, newBisectorDir);
                ShapeIntersection.LineRectangleIntersections(line, this.bounds.Value, out var i0, out var i1, this.epsilon);

                float2 larger = i0.y > i1.y ? i0 : i1;
                float2 smaller = i0.y > i1.y ? i1 : i0;
                float2 nextPoint = smaller;

                float2 dirToOtherPoint = leafNode.element.rightSite - rightNode.element.leftSite;
                float2 dirToSmaller = smaller - rightNode.element.leftSite;

                float otherPointDot = math.dot(dirToOtherPoint, newBisectorDir);
                float smallerDot = math.dot(dirToSmaller, newBisectorDir);

                if ((otherPointDot > 0 && smallerDot > 0) || (otherPointDot < 0 && smallerDot < 0))
                {
                    nextPoint = larger;

                    //AlgoUtil.Swap(ref leftEdgeIdx, ref rightEdgeIdx);
                    //AlgoUtil.Swap(ref leftHalfEdge, ref rightHalfEdge);
                }

                int2 newIndices = new int2();
                this.vertices.Add(nextPoint);
                this.vertices.Add(eventPoint.circlePosition);

                newIndices.x = this.vertices.Length - 2;
                newIndices.y = this.vertices.Length - 1;

                int currentEdgeCount = this.halfEdges.Length;

                var breakEdge0 = new HalfEdge(-1, -1, newIndices.x, newIndices.y, currentEdgeCount + 1);
                var breakEdge1 = new HalfEdge(-1, -1, newIndices.y, newIndices.x, currentEdgeCount);

                float2 rightCircleDir = math.normalize(this.vertices[breakEdge0.vertexBack] - this.vertices[breakEdge0.vertexFwd]);

                float2 leftDir = math.normalize(this.vertices[leftHalfEdge.vertexFwd] - this.vertices[leftHalfEdge.vertexBack]);
                float2 rightDir = math.normalize(this.vertices[rightHalfEdge.vertexFwd] - this.vertices[rightHalfEdge.vertexBack]);

                float2 leftTwinDir = -leftDir;
                float2 rightTwinDir = -rightDir;


                float leftAngle = Vector2.SignedAngle(rightCircleDir, leftDir);
                float rightAngle = Vector2.SignedAngle(rightCircleDir, rightDir);
                if (leftAngle < 0.0f) leftAngle += 360.0f;
                if (rightAngle < 0.0f) rightAngle += 360.0f;

                float leftTwinAngle = (leftAngle + 180.0f) % 360.0f;
                float rightTwinAngle = (rightAngle + 180.0f) % 360.0f;

                int leftIdx = leftHalfEdge.vertexBack;
                int rightIdx = rightHalfEdge.vertexBack;


                if(leftAngle > leftTwinAngle)
                {
                    leftHalfEdge.back = currentEdgeCount;
                    breakEdge0.fwd = leftEdgeIdx;

                    this.halfEdgeSites.Add(this.halfEdgeSites[leftEdgeIdx]);
                    if (rightAngle < rightTwinAngle)
                    {
                        leftTwinEdge.fwd = rightEdgeIdx;
                        rightHalfEdge.back = leftHalfEdge.twin;
                        rightTwinEdge.fwd = currentEdgeCount + 1;
                        breakEdge1.back = rightHalfEdge.twin;

                        this.halfEdgeSites[rightEdgeIdx] = this.halfEdgeSites[leftHalfEdge.twin];
                        this.halfEdgeSites.Add(this.halfEdgeSites[rightHalfEdge.twin]);

                    } else
                    {
                        leftTwinEdge.fwd = rightHalfEdge.twin;
                        rightTwinEdge.back = leftHalfEdge.twin;
                        rightHalfEdge.fwd = currentEdgeCount + 1;
                        breakEdge1.back = rightEdgeIdx;

                        this.halfEdgeSites.Add(this.halfEdgeSites[rightEdgeIdx]);
                        rightIdx = rightHalfEdge.vertexFwd;
                    }

                } else
                {
                    leftTwinEdge.back = currentEdgeCount;
                    breakEdge0.fwd = leftHalfEdge.twin;

                    this.halfEdgeSites.Add(this.halfEdgeSites[leftHalfEdge.twin]);
                    if (rightAngle < rightTwinAngle)
                    {
                        leftHalfEdge.fwd = rightEdgeIdx;
                        rightHalfEdge.back = leftEdgeIdx;
                        rightTwinEdge.fwd = currentEdgeCount + 1;
                        breakEdge1.back = rightHalfEdge.twin;

                        this.halfEdgeSites[rightEdgeIdx] = this.halfEdgeSites[leftEdgeIdx]; 
                        this.halfEdgeSites.Add(this.halfEdgeSites[rightHalfEdge.twin]);
                    }
                    else
                    {
                        leftHalfEdge.fwd = rightHalfEdge.twin;
                        rightTwinEdge.back = leftEdgeIdx;
                        rightHalfEdge.fwd = currentEdgeCount + 1;
                        breakEdge1.back = rightEdgeIdx;

                        this.halfEdgeSites.Add(this.halfEdgeSites[rightEdgeIdx]);
                        rightIdx = rightHalfEdge.vertexFwd;
                    }
                    leftIdx = leftHalfEdge.vertexFwd;
                }



                this.vertices[leftIdx] = eventPoint.circlePosition;
                this.vertices[rightIdx] = eventPoint.circlePosition;

                this.halfEdges.Add(breakEdge0);
                this.halfEdges.Add(breakEdge1);

                this.halfEdges[leftEdgeIdx] = leftHalfEdge;
                this.halfEdges[rightEdgeIdx] = rightHalfEdge;

                this.halfEdges[leftHalfEdge.twin] = leftTwinEdge;
                this.halfEdges[rightHalfEdge.twin] = rightTwinEdge;

                //Point to the new edge at the new breakpoint
                rightNode.element.halfEdgePtr = currentEdgeCount;
                status.m_NodeBuffer[rightPointer.node] = rightNode;

                if (leftPointer.node >= 0)
                {
                    var leftNode = status.m_NodeBuffer[leftPointer.node];
                    var leftElem = leftNode.element;

                    float2 leftBreakpoint = leftElem.Midpoint();
                    float2 leftBisectorDir = leftElem.BisectorDirection();

                    if (this.TestConvergence(leftBreakpoint, leftBisectorDir, newBreakpoint, newBisectorDir, out var circlePoint))
                    {
                        //This is allowed, because the intersection of two bisector lines is the circumcenter of a triangle
                        //(and analogously, the circumcenter of a tetrahedron is the intersection of three bisector planes etc.)
                        float circleRadius = math.length(leftElem.rightSite - circlePoint);
                        float2 circleEventPoint = circlePoint - new float2(0, 1) * circleRadius;
                        if (circleEventPoint.y <= this.sweepLine)
                        {

                            var circleEvent = new EventPoint()
                            {
                                leafPtr = leftPointer.node,
                                position = circleEventPoint,
                                type = EventType.CIRCLE_EVENT,
                                circlePosition = circlePoint,
                                site = -1,
                            };
                            eventQueue.Insert(circleEvent, out int eventNodeIdx);

                            leftElem.rightCircleEventPtr = eventNodeIdx;
                            leftNode.element = leftElem;
                            status.m_NodeBuffer[leftPointer.node] = leftNode;
                        }
                    
                    }
                }

                
                leftPointer = status.GetClosestPointer(leafNode.element, out _);
                if (leftPointer.forwards >= 0)
                {
                    var rightElem = rightNode.element;

                    float2 rightBreakpoint = rightElem.Breakpoint(this.sweepLine, this.epsilon);
                    float2 rightBisectorDir = rightElem.BisectorDirection();

                    if (this.TestConvergence(newBreakpoint, newBisectorDir, rightBreakpoint, rightBisectorDir, out var circlePoint))
                    {
                        float circleRadius = math.length(leafNode.element.rightSite - circlePoint);
                        float2 circleEventPoint = circlePoint + new float2(0, 1) * circleRadius;

                        var circleEvent = new EventPoint()
                        {
                            leafPtr = leftPointer.node,
                            position = circleEventPoint,
                            type = EventType.CIRCLE_EVENT,
                            circlePosition = circlePoint,
                            site = -1,
                        };
                        eventQueue.Insert(circleEvent, out int eventNodeIdx);

                        leafNode.element.rightCircleEventPtr = -1;
                        status.m_NodeBuffer[leftPointer.node] = leafNode;
                    }
                }
            }

            public EventPoint FetchNextEvent(ref NativeSortedList<EventPoint, EventPointComparer> eventQueue, ref NativeSortedList<StatusEntry, StatusEntryComparer> status)
            {
                //Fetching with random access is a log(n) operation (see manual) -> same as priority queue
                //However, we also need pointers to the "queue" -> binary heap is not well suited for this
                //Therefore queue is a sorted list
                var nextEvent = eventQueue[0];
                eventQueue.Remove(nextEvent);
                this.sweepLine = nextEvent.position.y;
                status.comparer.sweepLine = this.sweepLine;
                return nextEvent;
            }

            public void InitBoundaryValues()
            {
                this.sweepLine = this.bounds.Value.yMax;
                this.sweepEnd = this.bounds.Value.yMin;
            }

            public void Execute()
            {
                this.InitBoundaryValues();

                var statusComparer = new StatusEntryComparer()
                {
                    epsilon = this.epsilon,
                    sweepLine = this.sweepLine,
                };

                var eventQueue = new NativeSortedList<EventPoint, EventPointComparer>(new EventPointComparer() { epsilon = this.epsilon }, Allocator.Temp);

                //Fortune's Algorithm requires the removal of an arc, followed by the insertion of some new ones. If a balanced BST were
                //used, this would require the insertion of a subtree of height of at least 2. This would unbalance the tree, which
                //means it has to be rebalanced, which is quite a headache - mentally and performance-wise

                //So to circumvent this, and also because it is probably faster anyway and much easier, we use a skip list instead
                //Insertion is then simply... inserting! No rebalancing or anything.
                //Drawback: Memory ( AVL-Tree overhead per node is 18 Bytes while Skip-List is 40 Bytes in the limit)

                var status = new NativeSortedList<StatusEntry, StatusEntryComparer>(statusComparer, Allocator.Temp);


                for (int i = 0; i < this.points.Length; i++)
                {
                    var eventPoint = new EventPoint()
                    {
                        position = this.points[i],
                        leafPtr = -1,
                        type = EventType.SITE_EVENT,
                        site = i,
                    };

                    eventQueue.Insert(eventPoint);
                }

                while (!eventQueue.IsEmpty())
                {
                    var nextEvent = this.FetchNextEvent(ref eventQueue, ref status);
                    //Circle Events can be out of bounds!
                    if (nextEvent.position.y < this.sweepEnd) break;
                    switch (nextEvent.type)
                    {
                        case EventType.SITE_EVENT:
                            this.HandleSiteEvent(nextEvent, ref eventQueue, ref status);
                            break;
                        case EventType.CIRCLE_EVENT:
                            this.HandleCircleEvent(nextEvent, ref eventQueue, ref status);
                            break;
                    }
                }
            }
        }

        [BurstCompile]
        public unsafe struct Voronoi2DCleanup : IJob
        {
            [NoAlias]
            public NativeList<float2> vertices;

            [NoAlias]
            public NativeList<HalfEdge> halfEdges;


            public void Execute()
            {
                
            }
        }

        */

        [BurstCompile]
        public struct Voronoi2DLookupTableJob : IJobParallelFor
        {
            public int2 gridSize;

            [ReadOnly, NoAlias]
            public NativeReference<Rect> bounds;

            [ReadOnly, NoAlias]
            public NativeArray<float2> sites;

            [NativeDisableParallelForRestriction, WriteOnly, NoAlias]
            public NativeArray<int> table;

            public void Execute(int index)
            {
                int x = index % this.gridSize.x;
                int y = index / this.gridSize.y;

                float xPerPoint = this.bounds.Value.width / (float)this.gridSize.x;
                float yPerPoint = this.bounds.Value.height / (float)this.gridSize.y;

                float2 pos = (float2)this.bounds.Value.min + new float2(x * xPerPoint, y * yPerPoint);

                int closestIdx = 0;
                float closest = math.distancesq(pos, this.sites[0]);
                for(int i = 1; i < this.sites.Length; i++)
                {

                    float distSq = math.distance(pos, this.sites[i]);
                    if(distSq < closest)
                    {
                        closestIdx = i;
                        closest = distSq;
                    }
                }

                this.table[index] = closestIdx;
            }
        }

        [BurstCompile(FloatPrecision = FloatPrecision.High)]
        public unsafe struct Voronoi2DFromDelaunayJob : IJob
        {
            public float epsilon;

            [ReadOnly, NoAlias]
            public NativeArray<float2> sites;

            [NoAlias]
            public NativeList<float2> voronoiVertices;

            [ReadOnly, NoAlias]
            public NativeList<HalfEdge> delaunayHalfEdges;

            [NoAlias]
            public NativeList<HalfEdge> voronoiHalfEdges;

            [NoAlias]
            public NativeList<int> halfEdgeSites;

            [NoAlias, ReadOnly]
            public NativeList<int3> delaunayTriangulation;

            [NoAlias, ReadOnly]
            public NativeParallelHashMap<int, int> delaunayHalfEdgeToTriangleMap;

            [NoAlias, ReadOnly]
            public NativeReference<Rect> bounds;

            private float2 IntersectWithBounds(HalfEdge halfEdge)
            {
                float2 vertexBack = this.sites[halfEdge.vertexBack];
                float2 vertexFwd = this.sites[halfEdge.vertexFwd];

                float2 dir = vertexFwd - vertexBack;
                float2 bisectorDir = dir.Perpendicular();
                float2 midPoint = (vertexFwd + vertexBack) * 0.5f;

                var line = new Line2D(midPoint, bisectorDir);

                ShapeIntersection.LineRectangleIntersections(line, this.bounds.Value, out float2 i0, out float2 i1, this.epsilon);

                float dot = math.dot(bisectorDir, i0 - vertexBack);
                return dot >= 0 ? i0 : i1;
            }

            private bool CircumcenterToTheLeft(float2 circumcenter, HalfEdge halfEdge)
            {
                float2 vertexBack = this.sites[halfEdge.vertexBack];
                float2 vertexFwd = this.sites[halfEdge.vertexFwd];

                float2 dir = vertexFwd - vertexBack;
                float2 bisectorDir = dir.Perpendicular();

                float2 dirToCenter = circumcenter - vertexBack;
                return math.dot(bisectorDir, dirToCenter) > 0;
            }

            private float2 GetHalfEdgeTargetSite(NativeArray<float2> circumcenters, int halfEdgeIdx, out bool circumcenterIntersection, out bool falseEdge)
            {
                circumcenterIntersection = false;
                falseEdge = false;

                var halfEdge = this.delaunayHalfEdges[halfEdgeIdx];

                int triangleIdx = this.delaunayHalfEdgeToTriangleMap[halfEdgeIdx];

                if (triangleIdx < 0)
                {
                    return this.IntersectWithBounds(halfEdge);
                }
                else
                {
                    if (this.bounds.Value.Contains(circumcenters[triangleIdx]))
                    {
                        return circumcenters[triangleIdx];
                    } else
                    {
                        circumcenterIntersection = true;
                        if (CircumcenterToTheLeft(circumcenters[triangleIdx], halfEdge))
                        {
                            return this.IntersectWithBounds(halfEdge);
                        } else
                        {
                            falseEdge = true;
                            return float2.zero;
                        }
                    }
                }
            }

            private int AddVoronoiHalfEdge(NativeArray<float2> circumcenters, int index, out bool iA, out bool iB)
            {
                bool falseEdge = false;

                int halfEdgeIdx = index;
                var halfEdge = this.delaunayHalfEdges[halfEdgeIdx];

                int twinEdgeIdx = halfEdge.twin;

                float2 pointA = this.GetHalfEdgeTargetSite(circumcenters, halfEdgeIdx, out iA, out bool falseEdgeA);
                float2 pointB = this.GetHalfEdgeTargetSite(circumcenters, twinEdgeIdx, out iB, out bool falseEdgeB);

                falseEdge |= falseEdgeA;
                falseEdge |= falseEdgeB;

                if (!falseEdge)
                {

                    int idxA = this.voronoiVertices.Length;
                    int idxB = this.voronoiVertices.Length + 1;

                    this.voronoiVertices.Add(pointA);
                    this.voronoiVertices.Add(pointB);

                    var voronoiHalfEdge = new HalfEdge()
                    {
                        vertexBack = idxA,
                        vertexFwd = idxB,
                        twin = -1,
                        back = -1,
                        fwd = -1,
                    };
                    this.voronoiHalfEdges.Add(voronoiHalfEdge);
                    this.halfEdgeSites.Add(halfEdge.vertexFwd);

                    return this.voronoiHalfEdges.Length - 1;
                }
                return -1;
            }

            private bool CanMoveForward(HalfEdge edge, int circleEnd)
            {
                if (edge.twin < 0) return false;

                var twinEdge = this.delaunayHalfEdges[edge.twin];
                int twinBackIdx = twinEdge.back;
                if (twinBackIdx < 0) return false;
                var twinEdgeBack = this.delaunayHalfEdges[twinBackIdx];
                return twinBackIdx != circleEnd && twinEdgeBack.vertexBack >= 0 && twinEdgeBack.vertexFwd >= 0;
            }

            private bool CanMoveBackward(HalfEdge edge, int circleEnd)
            {
                if (edge.fwd < 0) return false;

                var fwdEdge = this.delaunayHalfEdges[edge.fwd];

                if(fwdEdge.twin < 0) return false;

                var fwdTwinEdge = this.delaunayHalfEdges[fwdEdge.twin]; 
                return fwdEdge.twin >= 0 && fwdEdge.twin != circleEnd && fwdTwinEdge.vertexBack >= 0 && fwdTwinEdge.vertexFwd >= 0;
            }

            public void Execute()
            {
                this.voronoiVertices.Clear();
                this.voronoiHalfEdges.Clear();

                NativeArray<float2> circumcenters = new NativeArray<float2>(this.delaunayTriangulation.Length, Allocator.Temp);

                for(int i = 0; i < this.delaunayTriangulation.Length; i++)
                {
                    var triangleIndices = this.delaunayTriangulation[i];

                    var a = this.sites[triangleIndices.x];
                    var b = this.sites[triangleIndices.y];
                    var c = this.sites[triangleIndices.z];

                    var triangle = new NativeTriangle2D(a, b, c);
                    NativeTriangle2D.CalculateCircumcircle(triangle, out float2 center, out _);
#if !GDG_LENIENT_SAFETY_CHECKS
                    if(float.IsNaN(center.x) || float.IsNaN(center.y)) {
                        Debug.LogWarning("[Gimme DOTS Geometry]: Triangulation contains invalid or very small-angled triangles!");
                    }
#endif

                    circumcenters[i] = center;
                }

                NativeBitArray markedEdges = new NativeBitArray(this.delaunayHalfEdges.Length, Allocator.Temp);
                for(int i = 0; i < this.delaunayHalfEdges.Length; i++)
                {
                    if (markedEdges.IsSet(i)) continue;

                    var currentDelaunayEdge = this.delaunayHalfEdges[i];
                    if (currentDelaunayEdge.vertexBack < 0 || currentDelaunayEdge.vertexFwd < 0) continue;

                    bool iA, iB;

                    int currentVoronoiEdgeIdx = this.AddVoronoiHalfEdge(circumcenters, i, out bool startIA, out iB);

                    int startVoronoiEdgeIdx = currentVoronoiEdgeIdx;
                    markedEdges.Set(i, true);
                    if (currentVoronoiEdgeIdx < 0) continue;

                    while (CanMoveForward(currentDelaunayEdge, i) && !iB)
                    {
                        var twinEdge = this.delaunayHalfEdges[currentDelaunayEdge.twin];
                        currentDelaunayEdge = this.delaunayHalfEdges[twinEdge.back];
                        int nextVoronoiEdgeIdx = this.AddVoronoiHalfEdge(circumcenters, twinEdge.back, out iA, out iB);
                        if (nextVoronoiEdgeIdx < 0) continue;

                        var currentVoronoiEdge = this.voronoiHalfEdges[currentVoronoiEdgeIdx];
                        var nextVoronoiEdge = this.voronoiHalfEdges[nextVoronoiEdgeIdx];

                        currentVoronoiEdge.fwd = nextVoronoiEdgeIdx;
                        nextVoronoiEdge.back = currentVoronoiEdgeIdx;

                        this.voronoiHalfEdges[currentVoronoiEdgeIdx] = currentVoronoiEdge;
                        this.voronoiHalfEdges[nextVoronoiEdgeIdx] = nextVoronoiEdge;
                        

                        currentVoronoiEdgeIdx = nextVoronoiEdgeIdx;

                        markedEdges.Set(twinEdge.back, true);
                    }

                    bool completedCircle = false;
                    if (currentDelaunayEdge.twin >= 0)
                    {
                        var twinEdge = this.delaunayHalfEdges[currentDelaunayEdge.twin];
                        int twinBackIdx = twinEdge.back;
  
                        completedCircle = twinBackIdx == i;
                    }

                    if (!completedCircle) {

                        currentDelaunayEdge = this.delaunayHalfEdges[i];
                        currentVoronoiEdgeIdx = startVoronoiEdgeIdx;
                        iA = startIA;
                        while (CanMoveBackward(currentDelaunayEdge, i) && !iA)
                        {
                            var fwdEdge = this.delaunayHalfEdges[currentDelaunayEdge.fwd];
                            currentDelaunayEdge = this.delaunayHalfEdges[fwdEdge.twin];
                            int prevVoronoiEdgeIdx = this.AddVoronoiHalfEdge(circumcenters, fwdEdge.twin, out iA, out iB);
                            if (prevVoronoiEdgeIdx < 0) continue;

                            var currentVoronoiEdge = this.voronoiHalfEdges[currentVoronoiEdgeIdx];
                            var prevVoronoiEdge = this.voronoiHalfEdges[prevVoronoiEdgeIdx];

                            currentVoronoiEdge.back = prevVoronoiEdgeIdx;
                            prevVoronoiEdge.fwd = currentVoronoiEdgeIdx;

                            this.voronoiHalfEdges[currentVoronoiEdgeIdx] = currentVoronoiEdge;
                            this.voronoiHalfEdges[prevVoronoiEdgeIdx] = prevVoronoiEdge;

                            currentVoronoiEdgeIdx = prevVoronoiEdgeIdx;

                            markedEdges.Set(fwdEdge.twin, true);
                        }
                    } else
                    {
                        var currentVoronoiEdge = this.voronoiHalfEdges[currentVoronoiEdgeIdx];
                        var startVoronoiEdge = this.voronoiHalfEdges[startVoronoiEdgeIdx];

                        if (!iB)
                        {
                            startVoronoiEdge.back = currentVoronoiEdgeIdx;
                            currentVoronoiEdge.fwd = startVoronoiEdgeIdx;

                            this.voronoiHalfEdges[startVoronoiEdgeIdx] = startVoronoiEdge;
                            this.voronoiHalfEdges[currentVoronoiEdgeIdx] = currentVoronoiEdge;
                        }

                    }
                }

            }
        }

        [BurstCompile(FloatPrecision = FloatPrecision.High)]
        public unsafe struct Voronoi2DToPolygonsJob : IJob
        {
            public float epsilon;

            [NoAlias]
            public NativeList<float2> vertices;

            [NoAlias]
            public NativeList<HalfEdge> halfEdges;

            [NoAlias]
            public NativeArray<NativePolygon2D> polygons;

            [NoAlias, ReadOnly]
            public NativeReference<Rect> bounds;

            [NoAlias, ReadOnly]
            public NativeList<int> halfEdgeSites;

            [NoAlias, WriteOnly]
            public NativeArray<int> polygonSites;

            private int DiagonalIdx(float2 point, float2 bottomLeft, float2 bottomRight, float2 topRight, float2 topLeft)
            {
                if (math.all(math.abs(point - bottomLeft) < this.epsilon)) return 0;
                if (math.all(math.abs(point - bottomRight) < this.epsilon)) return 1;
                if (math.all(math.abs(point - topRight) < this.epsilon)) return 2;
                if (math.all(math.abs(point - topLeft) < this.epsilon)) return 3;
                return -1;
            }

            private int EdgeIdx(float2 point, float2 bottomLeft, float2 bottomRight, float2 topRight, float2 topLeft)
            {
                float diffMinX = math.abs(point.x - bottomRight.x);
                float diffMaxX = math.abs(point.x - topLeft.x);

                float diffMinY = math.abs(point.y - bottomLeft.y);
                float diffMaxY = math.abs(point.y - topRight.y);

                if (diffMinY < this.epsilon) return 0;
                if (diffMinX < this.epsilon) return 1;
                if (diffMaxY < this.epsilon) return 2;
                if (diffMaxX < this.epsilon) return 3;

                if (diffMinY < diffMinX && diffMinY < diffMaxX && diffMinY < diffMaxY) return 0;
                if (diffMinX < diffMaxX && diffMinX < diffMaxY) return 1;
                if (diffMaxY < diffMaxX) return 2;
                return 3;
            }

            private float2 SelectCorner(int idx, float2 bottomLeft, float2 bottomRight, float2 topRight, float2 topLeft)
            {
                switch(idx)
                {
                    case 0:
                        return bottomLeft;
                    case 1:
                        return bottomRight;
                    case 2:
                        return topRight;
                    case 3:
                        return topLeft;
                }
                return float2.zero;
            }

            private void CompleteBoundaryPolygon(int backEdgeIdx, int fwdEdgeIdx, int backPointIdx, int fwdPointIdx,
                float2 bottomLeft, float2 bottomRight, float2 topRight, float2 topLeft)
            {
                //There are essentially only four cases, but we have to be careful about the diagonals, and choose the
                //edge that is "closer" (needs less insertions)

                //Each 90 will add one additional vertex to the boundary polygon
                //  Same Edge              90                 180                270
                //  +-+----+-+          +---+----+          +--+-----+          +---+----+
                //  |  \__/  |          |#_/     |          |###\    |          |  /#####|
                //  |        |          +/       |          |####|   |          | |######|
                //  |        |          |        |          |####|   |          +/#######|
                //  +--------+          +--------+          +----+---+          +--------+

                float2 forward = this.vertices[fwdPointIdx];
                float2 back = this.vertices[backPointIdx];

                int fwdDiagIdx = this.DiagonalIdx(forward, bottomLeft, bottomRight, topRight, topLeft);
                int backDiagIdx = this.DiagonalIdx(back, bottomLeft, bottomRight, topRight, topLeft);

                int fwdBorderEdge = this.EdgeIdx(forward, bottomLeft, bottomRight, topRight, topLeft);
                int backBorderEdge = this.EdgeIdx(back, bottomLeft, bottomRight, topRight, topLeft);

                //Special case: Both points are on corners
                if (fwdDiagIdx >= 0 && backDiagIdx >= 0)
                {
                    //Points are the diagonal of the boundary - one point needs to be inserted
                    if (math.abs(fwdDiagIdx - backDiagIdx) == 2)
                    {
                        int cornerIdx = (fwdDiagIdx + 1) % 4;
                        float2 cornerVertex = this.SelectCorner(cornerIdx, bottomLeft, bottomRight, topRight, topLeft);

                        int vertexIdx = this.vertices.Length;
                        this.vertices.Add(cornerVertex);

                        int firstHalfEdgeIdx = this.halfEdges.Length;
                        int secondHalfEdgeIdx = this.halfEdges.Length + 1;

                        var firstHalfEdge = new HalfEdge()
                        {
                            back = fwdEdgeIdx,
                            fwd = secondHalfEdgeIdx,
                            twin = -1,
                            vertexBack = fwdPointIdx,
                            vertexFwd = vertexIdx
                        };

                        var secondHalfedge = new HalfEdge()
                        {
                            back = firstHalfEdgeIdx,
                            fwd = backEdgeIdx,
                            twin = -1,
                            vertexBack = vertexIdx,
                            vertexFwd = backPointIdx,
                        };

                        this.halfEdges.Add(firstHalfEdge);
                        this.halfEdges.Add(secondHalfedge);

                        var fwdEdge = this.halfEdges[fwdEdgeIdx];
                        fwdEdge.fwd = firstHalfEdgeIdx;
                        this.halfEdges[fwdEdgeIdx] = fwdEdge;

                        var tmpBackEdge = this.halfEdges[backEdgeIdx];
                        tmpBackEdge.back = secondHalfEdgeIdx;
                        this.halfEdges[backEdgeIdx] = tmpBackEdge;

                        return;
                    }
                    //Both points can be on the same edge
                    else
                    {
                        //Either left or right
                        if(math.abs(forward.x - back.x) < this.epsilon) {

                            //Because of how the edge method is set up, they have to be 90 apart
                            if(fwdBorderEdge % 2 == 0)
                            {
                                backBorderEdge = fwdBorderEdge;
                            } else
                            {
                                fwdBorderEdge = backBorderEdge;
                            }
                        }
                        //Top or bottom
                        else
                        {
                            if(fwdBorderEdge % 2 == 1)
                            {
                                backBorderEdge = fwdBorderEdge;
                            } else
                            {
                                fwdBorderEdge = backBorderEdge;
                            }
                        }
                    }
                //Forward on corner - choose closest counter-clockwise
                } else if(fwdDiagIdx >= 0)
                {
                    fwdBorderEdge = fwdDiagIdx;
                }
                //Backwards on corner - choose closest clockwise
                else if(backDiagIdx >= 0)
                {
                    backBorderEdge = MathUtilDOTS.Mod(backDiagIdx - 1, 4);
                }

                int current = fwdBorderEdge;
                int end = backBorderEdge;

                int prevEdgeIdx = fwdEdgeIdx;
                int prevVertexIdx = fwdPointIdx;
                while (current != end)
                {
                    current = (current + 1) % 4;

                    float2 cornerVertex = this.SelectCorner(current, bottomLeft, bottomRight, topRight, topLeft);

                    int vertexIdx = this.vertices.Length;
                    this.vertices.Add(cornerVertex);

                    int halfEdgeIdx = this.halfEdges.Length;

                    var halfEdge = new HalfEdge()
                    {
                        back = prevEdgeIdx,
                        twin = -1,
                        vertexBack = prevVertexIdx,
                        vertexFwd = vertexIdx,
                        fwd = -1,
                    };

                    this.halfEdges.Add(halfEdge);

                    var prevEdge = this.halfEdges[prevEdgeIdx];
                    prevEdge.fwd = halfEdgeIdx;
                    this.halfEdges[prevEdgeIdx] = prevEdge;

                    prevEdgeIdx = halfEdgeIdx;
                    prevVertexIdx = vertexIdx;
                }

                var backEdge = this.halfEdges[backEdgeIdx];

                int lastHalfEdgeIdx = this.halfEdges.Length;
                var lastHalfEdge = new HalfEdge()
                {
                    back = prevEdgeIdx,
                    twin = -1,
                    vertexBack = prevVertexIdx,
                    vertexFwd = backEdge.vertexBack,
                    fwd = backEdgeIdx
                };

                this.halfEdges.Add(lastHalfEdge);
                this.halfEdges[lastHalfEdgeIdx] = lastHalfEdge;

                var lastPrevEdge = this.halfEdges[prevEdgeIdx];
                lastPrevEdge.fwd = lastHalfEdgeIdx;
                this.halfEdges[prevEdgeIdx] = lastPrevEdge;     

                backEdge.back = lastHalfEdgeIdx;
                this.halfEdges[backEdgeIdx] = backEdge;
            }

            public void Execute()
            {
                NativeBitArray markedEdges = new NativeBitArray(this.halfEdges.Length, Allocator.Temp);

                //=== Part 1: Find missing vertices and edges along the Voronoi border ===

                float2 bottomLeft = this.bounds.Value.min;
                float2 topRight = this.bounds.Value.max;

                float2 bottomRight = new float2(topRight.x, bottomLeft.y);
                float2 topLeft = new float2(bottomLeft.x, topRight.y);

                int originalHalfEdges = this.halfEdges.Length;

                NativeParallelHashMap<int, FixedList128Bytes<int2>> endings = new NativeParallelHashMap<int, FixedList128Bytes<int2>>(originalHalfEdges, Allocator.Temp);

                for(int i = 0; i < originalHalfEdges; i++)
                {
                    if (markedEdges.IsSet(i)) continue;

                    markedEdges.Set(i, true);

                    int backEdgeIdx = i;
                    int fwdEdgeIdx = i;

                    bool foundBack = false;
                    var currentHalfEdge = this.halfEdges[i];
                    while(currentHalfEdge.back != i)
                    {
                        int prevEdgeIdx = currentHalfEdge.back;
                        if(prevEdgeIdx < 0)
                        {
                            foundBack = true;
                            break;
                        }
                        var prevEdge = this.halfEdges[prevEdgeIdx];

                        currentHalfEdge = prevEdge;
                        markedEdges.Set(prevEdgeIdx, true);
                        backEdgeIdx = prevEdgeIdx;
                    }

                    if(foundBack)
                    {
                        while(currentHalfEdge.fwd >= 0)
                        {
                            fwdEdgeIdx = currentHalfEdge.fwd;
                            currentHalfEdge = this.halfEdges[fwdEdgeIdx];
                            markedEdges.Set(fwdEdgeIdx, true);
                        }

                        int2 ending = new int2(backEdgeIdx, fwdEdgeIdx);

                        int site = this.halfEdgeSites[fwdEdgeIdx];

                        if(!endings.ContainsKey(site))
                        {
                            endings.Add(site, new FixedList128Bytes<int2>());
                        }
                        var list = endings[site];
                        list.Add(ending);
                        endings[site] = list;

                    }
                }

                //=== Part 2: Complete the boundary ===

                foreach(var ending in endings)
                {
                    var list = ending.Value;
                    for(int i = 0; i < list.Length; i++)
                    {
                        int nextIdx = (i + 1) % list.Length;
                        int2 currentEdge = list[i];
                        int2 nextEdge = list[nextIdx];

                        int fwdEdgeIdx = currentEdge.y;
                        int backEdgeIdx = nextEdge.x;

                        var fwdEdge = this.halfEdges[fwdEdgeIdx];
                        var backEdge = this.halfEdges[backEdgeIdx];

                        this.CompleteBoundaryPolygon(backEdgeIdx, fwdEdgeIdx, backEdge.vertexBack, fwdEdge.vertexFwd,
                            bottomLeft, bottomRight, topRight, topLeft);
                    }
                }

                //=== Part 3: Find all polygons by moving along the circles ===

                //We have possibly new edges, so we have to create a possibly a larger array
                NativeBitArray loopedEdges = new NativeBitArray(this.halfEdges.Length, Allocator.Temp);

                int circleCount = 0;
                for(int i = 0; i < this.halfEdges.Length; i++)
                {
                    if (loopedEdges.IsSet(i)) continue;

#if !GDG_LENIENT_SAFETY_CHECKS
                    if(circleCount >= this.polygons.Length)
                    {
                        Debug.LogWarning("[Gimme DOTS Geometry]: Number of circles / polygons created from Voronoi exceeds the number" +
                            "of sites. This hints at degeneracies from the Voronoi Job. Returning the polygons that were generated so far");
                        break;
                    }
#endif

                    var polygon = this.polygons[circleCount];

                    var currentHalfEdge = this.halfEdges[i];
                    int vertexIdx = currentHalfEdge.vertexBack;
                    var vertex = this.vertices[vertexIdx];
                    polygon.points.Add(vertex);

                    loopedEdges.Set(i, true);
                    while(currentHalfEdge.fwd != i)
                    {
                        int nextEdgeIdx = currentHalfEdge.fwd;
                        if(nextEdgeIdx < 0)
                        {
                            //Due to floating point precision problems, it may happen that we get a
                            //negative values - most of the time because we receive a line instead of
                            //a triangle (well, a triangle with a zero-length edge from delaunay)

                            //In that case, we simply clear the polygon altogether and abort the search
                            if(currentHalfEdge.back >= 0)
                            {
                                loopedEdges.Set(currentHalfEdge.back, true);
                            }
                            polygon.points.Clear();
                            break;
                        }
                        var nextEdge = this.halfEdges[nextEdgeIdx];

                        vertexIdx = nextEdge.vertexBack;
                        vertex = this.vertices[vertexIdx];
                        polygon.points.Add(vertex);

                        currentHalfEdge = nextEdge;
                        loopedEdges.Set(nextEdgeIdx, true);
                    }
                    this.polygonSites[circleCount] = this.halfEdgeSites[i];
                    this.polygons[circleCount] = polygon;
                    circleCount++;
                }

            }
        }


    }


}
